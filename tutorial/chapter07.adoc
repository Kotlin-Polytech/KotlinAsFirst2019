= 7. Файловые операции

Программы, которые мы пишем, так или иначе должны взаимодействовать с пользователем и внешней средой --
операционной системой, устройствами компьютера, сетью Интернет.
Простейшим способом взаимодействия является ввод с консоли и вывод на консоль,
но сейчас такой способ применяется крайне редко.
Более совершенным способом взаимодействия являются __файлы__ --
многие программы берут из них настроечную или входную информацию,
и используют их для сохранения результатов своей работы или различных настроек.
Например, всевозможные __редакторы__ позволяют открывать файлы в определённом формате,
просматривать и/или изменять их, сохранять файлы на диске компьютера или в сети Интернет.

В библиотеке Java внутри пакета `java.io` имеется ряд типов, обеспечивающих возможность работы с файлами,
а библиотека Котлина дополняет их некоторыми удобными возможностями.
Как обычно, рассмотрим часть этих возможностей на примере.

[source,kotlin]
----
import java.io.File
/**
 * Пример
 *
 * Во входном файле с именем inputName содержится некоторый текст.
 * Вывести его в выходной файл с именем outputName, выровняв по левому краю,
 * чтобы длина каждой строки не превосходила lineLength.
 * Слова в слишком длинных строках следует переносить на следующую строку.
 * Слишком короткие строки следует дополнять словами из следующей строки.
 * Пустые строки во входном файле обозначают конец абзаца,
 * их следует сохранить и в выходном файле
 */
fun alignFile(inputName: String, lineLength: Int, outputName: String) {
    val writer = File(outputName).bufferedWriter()
    var currentLineLength = 0
    fun append(word: String) {
        if (currentLineLength > 0) {
            if (word.length + currentLineLength >= lineLength) {
                writer.newLine()
                currentLineLength = 0
            } else {
                writer.write(" ")
                currentLineLength++
            }
        }
        writer.write(word)
        currentLineLength += word.length
    }
    for (line in File(inputName).readLines()) {
        if (line.isEmpty()) {
            writer.newLine()
            if (currentLineLength > 0) {
                writer.newLine()
                currentLineLength = 0
            }
            continue
        }
        for (word in line.split(Regex("\\s+"))) {
            append(word)
        }
    }
    writer.close()
}
----

Краеугольный тип, используемый для работы с файлами в Котлине -- тип `java.io.File`.
В соответствии с названием, он предназначен для различных операций с файлами;
объект этого типа соответствует какому-либо реальному файлу, чаще всего находящемуся на жёстком диске.
Для создания файла используется специальная функция-конструктор: `File(inputName)` или `File(outputName)` в примере.
Если в аргументе конструктора указано только имя файла -- поиск файла происходит в текущей директории,
а если аргумент содержит также путь к файлу -- то в директории, указанной этим путём.
Специфика конструктора заключается в том, что его имя совпадает с типом объекта, которую он создаёт,
и он имеет результат соответствующего типа. 
Более подробно мы поговорим о конструкторах в следующем уроке.

Обмен данными с файлом может происходить в режиме чтения либо в режиме записи.
В режиме чтения информации, заданное имя должно соответствовать уже существующему файлу.
Один из способов получения информации из файла -- вызов функции `file.readLines()`.
Результат вызова -- список строк, из которых состоит файл.
Каждый `String` в этом списке соответствует одной строке файла,
строки файла разделяются символом "возврат каретки" и / или "новая строка".

В режиме записи информации, заданное имя может не соответствовать существующему файлу -- в этом случае он будет создан.
Для записи информации, необходимо создать один из объектов, обеспечивающих такую возможность.
В примере, таким объектом является `val writer = File(outputName).bufferedWriter()` --
то есть необходимо вызвать функцию `bufferedWriter()` на получателе, соответствующем исходному файлу.
Как видно из текста примера, `writer` (писатель) имеет функции `writer.newLine()` (добавление в файл новой строки),
`writer.write(string)` (добавление в файл заданной строки) и `writer.close()` (закрытие писателя,
выполняется строго ПОСЛЕ выполнения всех остальных действий и фиксирует итоговое состояние файла).

Мы перечислили все файловые операции, присутствующие в исходном примере.
Внутри цикла `for`, каждая из строк файла разбивается по пробелам на слова, с этой целью используется `Regex("\\s+")`.
В `currentLineLength` накапливается длина текущей строки ВЫХОДНОГО файла.
Если в текущей строке достаточно места для очередного слова ВХОДНОГО файла, слово добавляется в текущую строку,
в противном случае в файл добавляется перевод строки и слово добавляется в новую строку.
Пустые строки входного файла, как и сказано в задании, переносятся в выходной файл без изменений.

== За занавесом: чтение из файла

Пакет `java.io` позволяет работать с файлами на трёх разных уровнях:

1. Уровень отдельных байт. В этом случае файл воспринимается как массив или, точнее, как поток байт. Поток, в отличие от массива, можно только перебирать, с сильно ограниченными возможностями по возвращению назад. Для этой цели имеется тип `java.io.InputStream`.
1. Уровень символов. В этом случае файл воспринимается уже как поток символов типа `Char`, то есть каждые несколько байт файла превращаются в определённый символ -- с учётом заданной кодировки файла. Для этой цели имеется тип `java.io.InputStreamReader`, который внутри себя использует `InputStream` для чтения байт.
1. Уровень строк. На этом уровне файл воспринимается как набор строк `String`, составленных из символов по определённым правилам -- чаще всего используется разделение по отдельным строкам файла. Эту роль выполняет тип `java.io.BufferedReader`, использующий внутри себя `InputStreamReader` для чтения символов.

При программировании на Java каждый из этих объектов приходится создавать отдельно --
вначале `InputStream`, потом `InputStreamReader` и, наконец, `BufferedReader`.
Библиотека Котлина позволяет создать любой из этих объектов сразу, используя файл-получатель:

1. `file.inputStream()` создаёт байтовый поток.
1. `file.reader()` создаёт читатель символов, используя кодировку по умолчанию. `file.reader(Charset.forName("CP1251"))` создаёт писатель с заданной кодировкой (в данном случае CP1251).
1. Наконец, `file.bufferedReader()` создаёт буферизованный читатель строк. Опять-таки, может быть задана нужная кодировка, иначе используется кодировка по умолчанию.

Набор функций у данных трёх объектов различается.
У всех у них есть функция `close()`, закрывающая исходный файл в конце работы с потоком.
Также, у них имеется функция высшего порядка `use { ... }`,
выполняющая описанные в лямбде действия и закрывающая файл в конце своей работы автоматически.
Скажем, исходный пример можно было бы переписать с помощью `use` так:

[source,kotlin]
----
fun alignFile(inputName: String, lineLength: Int, outputName: String) {
    File(outputName).bufferedWriter().use {
        var currentLineLength = 0
        for (line in File(inputName).readLines()) {
            if (line.isEmpty()) {
                it.newLine()
                if (currentLineLength > 0) {
                    it.newLine()
                    currentLineLength = 0
                }
                continue
            }
            for (word in line.split(" ")) {
                if (currentLineLength > 0) {
                    if (word.length + currentLineLength >= lineLength) {
                        it.newLine()
                        currentLineLength = 0
                    } else {
                        it.write(" ")
                        currentLineLength++
                    }
                }
                it.write(word)
                currentLineLength += word.length
            }
        }
    }
}
----

Здесь исходный `BufferedWriter` в лямбде становится параметром `it`.
Заметим, что при использовании `use` исходный файл будет закрыт как при корректном завершении функции,
так и при возникновении исключения.

Кроме этого, каждый объект обладает своими методами для чтения информации:

1. `inputStream.read()` читает из `InputStream` очередной байт, возвращая его в виде результата типа `Int`. Если файл закончен, результат этой функции будет -1. `inputStream.read(byteArray)` читает сразу несколько байт, записывая их в массив байт (число прочитанных байт равно размеру массива). `inputStream.read(byteArray, offset, length)` записывает в `byteArray` `length` байт, начиная с индекса `offset`.
1. `reader.read()` читает из `InputStreamReader` очередной символ, возвращая его в виде результата типа `Int`. Здесь используется именно `Int`, а не `Char`, так как, во-первых, символ в общем случае может не поместиться в двухбайтовые тип и, во-вторых, чтобы вернуть -1 в случае неудачи. Есть аналогичные методы для чтения символьного массива (НЕ строки) с возможным указанием смещения и числа символов -- см. выше про байтовый массив.
1. `bufferedReader.readLine()` читает из `BufferedReader` очередную строку (до перевода строки). `bufferedReader.readLines()` читает сразу же все строки. Есть ряд других методов для работы со строками по отдельности.

Следует отметить, что все функции чтения информации могут бросить исключение `IOException` в том случае,
если чтение по какой-либо причине невозможно (например, если файл не существует или недоступен).

В примере, мы вообще не создавали `bufferedReader`, а использовали функцию `file.readLines()`.
Она создаёт `bufferedReader` внутри себя и обращается к его функции `readLines()`.
После чтения последней строки файл закрывается. Вариант вызова `file.readLines(charset)` позволяет дополнительно указать кодировку, в которой следует читать файл. Есть и другие варианты высокоуровневых функций чтения файла:

1. `file.forEachLine { line -> ... }`. Эта функция высшего порядка предполагает чтение строк файла по одной, и выполнение операции, указанной в лямбде (...) для каждой из этих строк. Достоинство такого подхода в том, что здесь мы не храним в памяти весь список строк из файла, как делает `file.readLines()`. Это может быть важно, если размер файла большой. С другой стороны, подобный вариант предполагает обработку строк по очереди, от предыдущей к следующей, и не обеспечивает никакой возможности возврата к уже обработанной строке. Вариант вызова `file.forEachLine(charset) { line -> ... }` позволяет дополнительно указать кодировку.
1. `file.useLines { lineSequence -> ... }`. Лямбда в этой функции высшего порядка работает с *последовательностью* строк файла `lineSequence`, тип которой `Sequence<String>`. Тип `Sequence` напоминает типы из библиотеки коллекций `Iterable` и `Collection`, последовательность строк можно перебрать с помощью цикла `for`, на ней можно вызывать ряд функций высшего порядка -- такие, как `map`, `filter`, `forEach` и так далее. Особенность функционирования последовательностей состоит в том, что они *ленивы*. Благодаря этому многие операции с последовательностями -- в частности, `map` и `filter` -- по факту не приводят к чтению их элементов (из файла или, в общем случае, из другого источника). 

== За занавесом: запись в файл

Запись в файл использует те же три уровня: байты `OutputStream`, символы `OutputStreamWriter` и строки `BufferedWriter`.
Для записи байт либо символов используются функции `write`,
аргументом которых может являться целое число (в котором хранится байт или код символа) или массив (опять-таки байт или символов).
Эти функции не имеют результата и бросают `IOException`, если файл недоступен для записи.
`BufferedWriter` может использовать функцию `write` также для записи строк.
Как и все три вида потоков чтения,
потоки записи необходимо закрывать после использования с помощью `close()` или `use { ... }`.

Сверх этого, для записи часто используется так называемый поток печати `PrintStream`.
В Котлине его можно создать из файла, используя функцию `file.printStream()`.
Поток печати расширяет обычный байтовый поток рядом дополнительных возможностей:

1. `printStream.println(...)` -- вывод заданной строки или строкового представления с последующим переходом на новую строку.
1. `printStream.print(...)` -- то же, но без перехода на новую строку.
1. `printStream.format(formatString, ...)` -- форматированный вывод (происходит по принципу, описанном в разделе 6).

== Упражнения

Откройте файл `srс/lesson7/task1/Files.kt` в проекте `KotlinAsFirst`.
Он содержит ряд задач, каждая из которых предполагает наличие входного и/или выходного файла.
Решите хотя бы одну-две из имеющихся задач, используя описанные в этом разделе приёмы.
Обратите внимание на задачи, помеченные как "Сложная" или "Очень сложная", попробуйте решить одну из них.

Протестируйте свою реализацию, используя тесты из `test/lesson7/task1/Tests.kt`.
Обратите внимание, что тесты используют готовые входные файлы, расположенные в директории `input` нашего проекта.
Убедитесь, что тесты успешно проходят, обязательно создайте два-три дополнительных теста.
Постарайтесь внутри этих тестов проверить какие-либо необычные ситуации,
которые могут возникнуть в выбранной вами задаче.

Поздравляем! Выполнив упражнения по этому разделу, вы успешно завершили базовую часть нашего курса.
Если вас интересует получение сертификата, прочитайте параграф "Получение сертификата Coursera" ниже.

== Дополнительное чтение

* Википедия "Синтаксический анализ"
* Википедия "Стек" (абстрактный тип данных)

== Получение сертификата Coursera / экзамен

Если вы проходили данный курс на Coursera,
после загрузки последнего задания вам придёт письмо от Coursera со ссылкой "Получить сертификат о прохождении курса".
Нажмите на данную ссылку и следуйтё указаниям сайта Coursera.

Если вы проходили данный курс на кафедре КСПТ СПбПУ, вы также можете получить сертификат Coursera,
если задания курса выполнены до окончания зачётной недели.
За информацией о регистрации на курс обратитесь к лектору курса.
После этого вам необходимо загрузить на Coursera все сделанные задания, и дальнейшая процедура будет аналогичной.

Экзамен по данному курсу на кафедре КСПТ СПбПУ заключается в решении экзаменационной задачи
(напоминающей задачи данного урока средней сложности). Для получения положительной оценки
необходимо продемонстрировать экзаменатору работающее на компьютере решение и проверяющие его тесты.

В каждом билете отдельно приведены требования,
необходимые для получения оценок "удовлетворительно", "хорошо" и "отлично".
Студент должен быть в состоянии объяснить экзаменатору своё решение,
использованные в нём элементы языка и стандартной библиотеки.
От претендентов на высокую оценку ожидается также способность обосновать,
почему задача решена именно так и провести сравнение с другими возможными вариантами решения.

На экзамене разрешается пользоваться конспектом, Интернетом, любыми книгами.
Запрещается общаться с кем-либо, кроме экзаменатора, пользоваться электронной почтой,
социальными сетями и другими средствами общения.

Максимальная длительность экзамена 2 часа 45 минут.
Из них 2 часа отводится на решение задачи и 30 минут на исправление замечаний экзаменатора,
15 минут остаются в резерве.
